<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="keywords" content="
			Nerver stop thinking
		">
    <meta name="description" content="杨小福的博客，记点笔记">
    <title>
         Nerver stop thinking 
    </title>
    <link rel="stylesheet" href="/css/public.css">
    <link rel="stylesheet" href="/css/page.css">
    <link rel="stylesheet" href="/css/monokai.min.css">
    <link rel="stylesheet" href="/css/post_add.css">
    <link id="theme-highlight" rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.9.1/styles/atelier-dune.light.min.css">
    <script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?0904845f91ea208faa55eaa72f93fab1";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
    </script>
</head>

<body>
    <div id="headerWrapper" class="cf">
        <header id="header" class="cf">
            <div id="logo">
                <h1 class="logo">
					<a href="/">Yangxiaofu</a>
				</h1>
                <div class="logo-subtitle">
                    programmer
                </div>
            </div>
            <nav id="main-nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/archives">博文</a></li>
                    <li><a href="/websites/index.html">网址导航</a></li>
                    <li><a href="/about">关于</a></li>
                </ul>
            </nav>
        </header>
    </div>
    
	<div id="pageWrapper">
		<div id="mainContent">
			<article class="post">
			<div class="items-wrap">
				
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				 	<div class="post-item">	
						<header>
							<h1>
								<a href="/2015/12/05/reading/matz-ruby/" target="_blank">松本行弘的程序世界——预览版</a>
							</h1>
							<div class="post-info">
								<span class="post-time">
									<a class="permalink" href="" >2015-12-05</a>
								</span>
								<span class="post-tag">
									
									
										<a class="tag" href="http://www.yangxiaofu.com/tags/pl/" target="_blank">pl</a>
									
										<a class="tag" href="http://www.yangxiaofu.com/tags/ruby/" target="_blank">ruby</a>
									
								</span>
							</div>
						</header>
						<div class="post-body">
							
								<div class="post-excerpt">
									<p>第一次读这本书，是我还在读书的时候，那时的我正为C++这样的语言而苦恼，就这样接触了ruby，ruby是一门动态类型的语言，语法优雅，非常灵活，也因为它我开始开发web程序。这本书并不是一本ruby程序指南，而是一本描述程序世界的书籍，虽然讲得不那么深入，确很广泛。</p>
<p><img src="/img/matz/matz.jpg" alt="matz"></p>
								</div>
								<div class="post-more">
									<h2 id="一、我为什么开发Ruby">一、我为什么开发Ruby</h2><h3 id="编程语言的重要性">编程语言的重要性</h3><p>语言体现了人类思考的本质。因为语言，人与人之间才能传递知识和交流思想，才能做深入的思考。在语言学领域，有一个Sapir-Whirf假说，认为语言可以影响说话者的思想，即语言的不同，造成了思想的不同。在这里，我觉得计算机语言很符合这个假说。程序员由于使用的编程语言不同，他的思考方法和编写出来的代码都会受到编程语言的很大影响。</p>
<h3 id="Ruby的原则">Ruby的原则</h3><p>Ruby编程语言的设计目标是轻松编程、提高开发效率。</p>
<p>三个原则：</p>
<ul>
<li>简洁性</li>
<li>扩展性</li>
<li>稳定性</li>
</ul>
<h4 id="简洁性">简洁性</h4><p>面向对象编程——面向对象的思想只是把数据和方法看作一个整体，当做对象来处理，并没有解决以前解决不了的问题。面向对象的方法并没有实现任何新的东西，却要在运行时判定要调用的方法，倾向于增大程序的运行开销。实现同样的算法，面向对象的程序往往更慢，过去计算机的执行速度不够快，所以不容许这样的浪费。</p>
<p>内存管理，不用的内存现在可用垃圾收集器自动释放，而不用程序员自己去释放。变量和表达式的类型检查，在执行时已经可以自动检查，而不用在编译时检查了。</p>
<p>如果可以把伪代码中非实质性的东西去掉，只保留描述算法的部分就直接运行，那么这种编程语言不就是最好的吗？ruby的目标就是成为开发效率高、“能直接运行的伪码式编程语言”。</p>
<h4 id="扩展性">扩展性</h4><p>编程语言作为软件开发工具，其最大的特征就是对要实现的功能没有限制。“如果想到就可以做到”，这听起来像小孩说的话，但这在编程语言的世界里，真的就是这么一回事。不管在什么领域，做什么处理，只要用一种编程语言编写出了程序，我们就可以说这种语言适用于这一领域。</p>
<p>实现扩展性的一个重要方法是抽象化。抽象化是指把数据和要做的处理都封装起来，就像一个黑盒子，我们不知道内部是如何实现的，但是可以用它。ruby在扩展性上看重的是如何最大限度地发挥程序员自身的能力。</p>
<h4 id="稳定性">稳定性</h4><p>我相信，作为在世界上广泛使用的编程语言，应该有稳定的语法，不能像随风飘荡的灯芯那样闪烁不定。注：作者以Lisp的宏为例，指出了提供巨大的扩展性的同时也使得程序难以理解和阅读。</p>
<h2 id="二、面向对象">二、面向对象</h2><p>程序员控制计算机，还是在为计算机工作？</p>
<p>阿尔法综合征——指在伺养宠物的时候，宠物狗误解了一直细心照顾它的主人的地位，反而感觉到它是主人，比主人更了不起。</p>
<p>几乎所有的编程语言都具备“图灵完备”的属性，无论何种编程语言都可以实现等价的程序，但这并不是说选择什么样的编程语言都一样。每一种语言都有自己的特征、属性、都各有长处和短处，写程序的难易程度也有很大的不同。</p>
<p>编程技巧：</p>
<ul>
<li>编程风格</li>
<li>算法</li>
<li>数据结构</li>
<li>设计模式</li>
<li>开发方法</li>
</ul>
<h3 id="面向对象编程">面向对象编程</h3><p>面向对象的设计方法是20世纪60年代后期，在诞生于瑞典的Simula编程语言中最早使用。Smalltalk编程语言对近代面向对象编程语言影响很大，可以称之为面向对象语言之母。到现在，大多数主流的编程语言使用的都是面向对象的设计方法。</p>
<h4 id="多态性">多态性</h4><p>多态就是可以把不同种类的东西当做相同的东西来处理。各种数据可以统一地处理、根据对象的不同自动选择最合适的方法而程序内部则不发生冲突、具备扩展性。</p>
<h4 id="数据抽象和继承">数据抽象和继承</h4><p>数据抽象有时也会称为封装，多态性、数据抽象和继承被称为面向对象编程的三原则。</p>
<h4 id="面向对象的历史">面向对象的历史</h4><p>Simula语言最早引入了数据和处理数据方法自动结合的抽象数据类型。随后，又增加了类和继承的功能。</p>
<p>Lisp的发展产生了许多很有创新的方法，多重继承、混合式和多重方法等。</p>
<p>C语言是面向过程的语言，在C语言中追加面向对象的功能，产出了C++。</p>
<h4 id="复杂性">复杂性</h4><p>虽然计算机的额性能年年在提高，但它的处理能力终究是有限的，而人类的理解力的局限性给软件生产力带来的限制性更大。为了找到迅速开发大规模复杂软件的方法，有时牺牲性能也在所不惜。</p>
<h4 id="结构化编程">结构化编程</h4><p>结构化编程的基本思想是有序地控制流程，即把程序的执行顺序限制为顺序、分支和循环3种，把共通的处理归结为例程。结构化编程引入了例程的概念，也就是把基本上相同的处理抽象成例程，其中不同的部分由外部传递进来的参数来对应。结构化编程的限制和抽象化是人类处理复杂软件的非常有效的方法。结构化编程的顺序、分支和循环可以实现一切算法，虽然降低了程序的复杂性和灵活性，但是程序的实现能力并没有降低。现在几乎所有的编程语言都支持结构化编程，结构化编程也成为了编程的基本常识。</p>
<h4 id="数据的抽象化">数据的抽象化</h4><p>结构化编程降低了程序流程的复杂性，但却不能解决数据的复杂性，面向对象就是为此而出现的。数据抽象是数据和处理方法的结合。对数据内容的处理和操作，必须通过事先定义好的方法来进行。数据和处理方法结合起来成为了黑盒子。</p>
<h4 id="继承">继承</h4><p>继承就是在保持既有类的性质的基础上而生成新类的方法。原有的类称为父类，新生成的类称为子类。子类继承父类所有的方法，如果需要可以增加新的方法，也可以重写从父类继承的方法。</p>
<ul>
<li>单一继承</li>
<li>多重继承（一个对象有多个父类，如一个公司员工可能同时是一个父亲、儿子）</li>
</ul>
<p>单一继承——单一继承关系是单纯的树结构，类之间的关系单纯就不会发生混乱，实现起来也比较简单。<br>多重继承——继承多个类，程序代码共享。单一继承可以实现的功能，多重继承都可以实现，但是类之间的关系会变得复杂，哪个类的功能继承自哪个类就变得难以理解。</p>
<p>多重继承导致的问题：</p>
<ul>
<li>结构复杂化</li>
<li>优先顺序模糊</li>
<li>功能冲突</li>
</ul>
<p>ruby中多重继承的实现——“Mix-in类”，Mix-in类是具有以下特征的抽象类：</p>
<ul>
<li>不能单独生成实例</li>
<li>不能继承普通类</li>
</ul>
<p>实现功能共享的方法是把共享的功能放在Mix-in类里面，然后把Mix-in类插入到继承树里面。</p>
<h3 id="Duck_Typing">Duck Typing</h3><blockquote>
<p>If it walks like a duck and quacks like a duck,it must be a duck(走起路来像鸭子，叫起来也像鸭子，那么它就是鸭子)</p>
</blockquote>
<p>动态类型的缺点：</p>
<ul>
<li>执行时才能发现错误</li>
<li>程序阅读可能不好理解</li>
<li>运行速度会比静态类型慢</li>
</ul>
<h4 id="元编程">元编程</h4><p>在ruby中可以方便的动态给类增加方法。静态类型的语言中这是很难做到的。</p>
<h4 id="反射">反射</h4><p>指在程序执行时取出程序的信息或者改变程序信息，实现对程序的动态操作。</p>
<h3 id="元编程和小编程语言">元编程和小编程语言</h3><p>DSL是针对特定领域的语言，小编程语言一般会具备如下功能：</p>
<ul>
<li>类型</li>
<li>字面量</li>
<li>表达式</li>
<li>运算符</li>
<li>语句</li>
<li>控制结构</li>
<li>声明</li>
<li>上下文相关</li>
<li>单位</li>
<li>词汇</li>
<li>层级数据</li>
</ul>
<h2 id="程序块">程序块</h2><p>程序块是ruby语言的特色之一，在方法调用时可以追加代码块。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">ary.each &#123; |x| puts x&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高阶函数">高阶函数</h3><p>ruby程序块功能的原理和高阶函数是一样的。高阶函数是指以函数作为参数的函数。为了实现高阶函数，编程语言中必须把函数和方法作为数据来处理。</p>
<h2 id="四、设计模式">四、设计模式</h2><p>设计模式指设计上经常反复使用的模式。在软件中，重用一般是通过库，各种软件共享处理过程、数据结构以及类等。但是只有库还不能达到充分地的共享，软件设计中除了库还有共通的部分即模式。</p>
<p>23种常用设计模式</p>
<p><img src="/img/matz/patterns.png" alt="设计模式"></p>
<h3 id="prototype模式">prototype模式</h3><p>Prototype(原型)模式”明确一个实例作为要生成对象的种类原型”，通过复制该实例来生成新的对象。<br>相对于类模式的编程，原型模式的编程的构成元素比较少，具有简单实现面向对象功能设计的倾向。</p>
<h2 id="五、Ajax">五、Ajax</h2><p>Ajax的最大特点是进行异步操作。异步意味着，Web浏览器的通信和页面更新是相互独立的。</p>
<p>老式的浏览器通信方式：<br>每当用户进行操作之后，需要更新页面，在得到服务器的响应之后，下一个页面才能显示出来。<br>Ajax的通信方式：<br>Ajax技术中，对于用户进行的操作，基本是由Javascript在Web浏览器中进行响应。仅在数据必须从服务器获取的情况下，才在后台进行异步通信。</p>
<p><img src="/img/matz/http.png" alt="http"></p>
<p>支撑Ajax的3个主要技术：</p>
<ul>
<li>Javascript</li>
<li>XML</li>
<li>DHTML</li>
</ul>
<p>Javascript进行异步通信的对象的名字是XMLHttpRequest.</p>
<p>DHTML:动态的HTML,可以动态地对HTML进行引用、修改和更新。它是利用装载在网页中的Javascript，使用DOM(文档对象模型)对网页数据进行操作。</p>
<p>Ajax网站特点：</p>
<ul>
<li>没有Web页面跳转</li>
<li>通过异步通信实现快速反应</li>
</ul>
<h2 id="第六章_Ruby_on_rails">第六章 Ruby on rails</h2><p>Web应用的基本是HTTP，一次HTTP处理经过如下的过程：</p>
<ul>
<li>Web浏览器对应于用户的操作，像Web服务器发出HTTP请求</li>
<li>web服务器根据请求，准备好发送到Web浏览器的数据</li>
<li>Web服务器把数据以HTTP响应的形式送还Web浏览器</li>
</ul>
<p>MVC模式对应上面的各个部分如下：</p>
<ul>
<li>Web浏览器发送来的HTTP请求通过Web服务器传给控制部分。Web应用框架的分配器(路由)把请求传递给合适的控制部分。</li>
<li>控制部分操作的模型和请求的信息相对应，同时指定显示使用的视图。视图从模型启动，一边引用模型一边准备发送给Web浏览器的数据。</li>
<li>Web服务器把数据以HTTP响应的形式送还Web浏览器。</li>
</ul>
<p><img src="/img/matz/mvc.png" alt="web应用中的MVC"></p>
<p>MVC的具体实现可能会有细微的差别，如rails的MVC与传统的MVC就有一些不同。</p>
<h2 id="第七章_文字编码">第七章 文字编码</h2><p>计算机能够处理图像、动画及各种应用程序固有的、多种多样的数据。但从CPU的层次来看，计算机所处理的各种数据都是用比特所表现的二进制数字。为了让计算机能够处理文字，就必须将文字变换为相应的数字。这种对应于文字的数值就称为文字编码。文字的集合称为字符集；在字符集中，每个字符都分配一个编码，这称为字符编码。计算机上仅仅用整数值来表示文字编码的方式称为文字编码方式。计算机不能处理文字本身，就要让文字与编码对应。与文字相对应的编码就称为文字编码。这样计算机只能处理分配了编码的文字，分配了编码的文字集合就称为文字集。</p>
<h3 id="为什么会发生乱码？">为什么会发生乱码？</h3><p>文字乱码最大原因是把程序的字符编码方式搞错了。把一种字符编码方式的数据按另一种字符编码方式来表示，结果就会完全不同。为了在计算机画面上表示文字，还需要文字编码及文字编码以外的东西。与某种文字编码相对应的文字应具备何种字形的信息由计算机掌握，根据需要，必须将字形在画面上表示出来。这样的字形数据称为字体。如果没有对应的字体信息，就会出现乱码。</p>
<h2 id="第八章_正则表达式">第八章 正则表达式</h2><p>正则表达式主要用来处理字符串，是一种描述字符串模式的微语言。</p>
<h2 id="第九章_整数和浮点小数">第九章 整数和浮点小数</h2><p>作为高级程序员，应该有更高的目标。如果计算机中能够自然计算的整数有上限，就要想办法引入多倍长以超越界限；为了能除尽，就引入有理数等。如何权衡计算效率以达到最大限度的平衡技巧。</p>
<h2 id="第十章_高速执行和并行处理">第十章 高速执行和并行处理</h2><p>两个法则：</p>
<ul>
<li>帕累托法则：80：20法则</li>
<li>摩尔法则：即大规模集成电路中的晶体管数每18个月翻一番。</li>
</ul>
<h2 id="第十一章_程序安全性">第十一章 程序安全性</h2><p>4种软件漏洞：</p>
<ul>
<li>DOS攻击</li>
<li>信息泄露</li>
<li>权限夺取</li>
<li>权限升格</li>
</ul>
<p>DOS攻击：也称拒绝服务攻击，是指妨碍软件正常运行的网络攻击手段。能够引起软件异常终止的程序错误，可以说全部都是引发DOS攻击的安全性程序错误。<br>信息泄漏：指不愿公开的信息被公开了，比如用户名被公开或密码暴露。</p>
<p>有代表性的攻击手段：</p>
<ul>
<li>缓冲区溢出</li>
<li>整数溢出</li>
<li>跨站脚本攻击(XSS)</li>
<li>SQL注入</li>
<li>跨站点伪造请求(CSRF)</li>
</ul>
								</div>
								<a class="postMore" href="javascript:void(0);" data-show="false">......查看全文</a>
							
						</div>
						<hr>
						</div>
				 	
				
				 	
				 	<div class="post-item">	
						<header>
							<h1>
								<a href="/2015/11/28/js-prototype/" target="_blank">prototype、__proto__、constructor、this——不懂别说会JS</a>
							</h1>
							<div class="post-info">
								<span class="post-time">
									<a class="permalink" href="" >2015-11-27</a>
								</span>
								<span class="post-tag">
									
									
										<a class="tag" href="http://www.yangxiaofu.com/tags/jquery/" target="_blank">jquery</a>
									
										<a class="tag" href="http://www.yangxiaofu.com/tags/js/" target="_blank">js</a>
									
								</span>
							</div>
						</header>
						<div class="post-body">
							
								<div class="post-excerpt">
									<p><img data-src="/img/prototype/so_many_questions.png" alt="so_many_questions"><br>刚开始接触js的时候，我的疑问就像上面密密麻麻的问题。。。</p>
<h2 id="JS对象">JS对象</h2><ul>
<li>每一个Javascript对象(null除外)都和另一个对象相关联，即原型，每一个对象都从原型继承属性。</li>
<li>所有通过对象直接量创建的对象都具有同一个原型对象，通过Object.prototype可以获得对原型对象的引用。</li>
<li>通过new关键字和构造函数创建的对象的原型就是构造函数的prototype属性的值</li>
<li>普通的原型对象属于普通对象，普通对象都具有原型(Object.prototype比较特殊，不继承任何属性)</li>
<li>所有的内置构造函数以及大部分自定义构造函数都具有一个继承自Object.prototype的原型</li>
<li>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> F();</span><br><span class="line">o.constructor === F	<span class="comment">/*true,指代类本身*/</span></span><br></pre></td></tr></table></figure>
								</div>
								<div class="post-more">
									<h2 id="Javascript中class的写法">Javascript中class的写法</h2><p>注：为和普通函数区别开，类的命名首字母一般是大写</p>
<p>下面定义了Cat、cat类<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写法一：*/</span></span><br><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:大写的猫"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"cat:小写的猫"</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写法二：*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:大写的猫"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:小写的猫"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里输出的结果是相同的，即类的命名首字母大写并不是强制的</p>
<h3 id="对象生成">对象生成</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objCat = <span class="keyword">new</span> Cat; <span class="comment">/*大写的猫对象*/</span></span><br><span class="line"><span class="keyword">var</span> objcat = <span class="keyword">new</span> cat; <span class="comment">/*小写的猫对象*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*输出*/</span></span><br><span class="line"><span class="built_in">console</span>.log(objCat, objcat);</span><br></pre></td></tr></table></figure>
<p><img src="/img/prototype/cat-01.png" alt="类的命名首字母大写并不是强制的"></p>
<p>从上面我们可以看到:对象objCat——&gt;<strong>proto</strong>[Cat类]——&gt;<strong>proto</strong>[Object对象],这就是所谓的继承链.</p>
<h2 id="prototype_VS_proto_对象">prototype VS <strong>proto</strong> 对象</h2><h3 id="添加prototype对象">添加prototype对象</h3><p>这里给Cat添加prototype对象,cat不做改动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*写法一：*/</span></span><br><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:大写的猫"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"cat:小写的猫"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"I like fish!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：同一个类生成的所有对象会共用类的prototype对象上挂载的方法和属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">redCat = <span class="keyword">new</span> Cat;</span><br><span class="line">greenCat = <span class="keyword">new</span> Cat;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(redCat.eat(), greenCat.eat());</span><br></pre></td></tr></table></figure>
<p>redCat和greenCat调用的是同一个方法即Cat.prototype.eat,所以都会输出”I like fish!”.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"I like fish!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>/<em>同样输出两个生成的对象</em>/</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(objCat, objcat);</span><br></pre></td></tr></table></figure>
<p><img src="/img/prototype/cat-02.png" alt="这里给Cat添加prototype对象,cat不做改动"></p>
<p>从上图可以发现大写的猫对象多输出了两行,这里出现了一个”<strong>proto</strong>“属性,那么它代表什么呢？因为这是我们的Cat类设置了prototype后Cat对象才出现的属性，所以我们可以猜测这两者之间有某种密切的关系，为了验证我们的想法，我们可以输出测试一下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(objCat.__proto__, Cat.prototype);</span><br></pre></td></tr></table></figure>
<p><img src="/img/prototype/cat-03.png" alt="console.log(objCat.__proto__, Cat.prototype)"></p>
<p>我们可以惊奇的发现输出结果一模一样，为了再次证明它们是同一个东西，我们再次进行验证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*注意这里是3个等号哦*/</span></span><br><span class="line"><span class="built_in">console</span>.log(objCat.__proto__ === Cat.prototype);  			<span class="comment">/*result:true*/</span></span><br><span class="line"><span class="built_in">console</span>.log(objCat.__proto__.eat(), Cat.prototype.eat());	<span class="comment">/*I like fish! I like fish!,调用了同一个 eat 方法*/</span></span><br></pre></td></tr></table></figure>
<p>从这里我们可以得一个结论：对象会继承类的prototype对象并存在一个名为”<strong>proto</strong>“的属性中,即对象的”<strong>proto</strong>“属性指向生成它的类的”prototype”对象</p>
<p class="text-important">protoype和<strong>proto</strong>统称为原型对象，但前者是在类中，后者是在对象中的表示，实例对象中没有prototype属性的。[js中的类是通过function来模拟的，每一个function都有一个prototype属性</p>

<h2 id="constructor属性">constructor属性</h2><p>构造函数的原型中存在预先定义好的constructor属性，对象继承的constructor均指代他们的构造函数。构造函数是类的标识，因此这个constructor属性为对象提供了类.</p>
<p>这句话怎么来理解呢？</p>
<p>1 .构造函数的原型中存在预定义好的constructor属性<br>2 .constructor指代他们的构造函数<br>3 .constructor属性为对象提供了类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CatConstructor = Cat.prototype.constructor;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Cat:"</span>, Cat, Cat.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"CatConstructor:"</span>, CatConstructor, CatConstructor.prototype);</span><br></pre></td></tr></table></figure>
<p>这里为了更清晰的理解上面这几个点，我们将Cat类的原型的constructor属性赋值给CatConstructor,然后分别打印他们本身以及他们的原型对象。</p>
<p><img src="/img/prototype/cat-04.png" alt="Cat.prototype.constructor"></p>
<p>从上图我们可以发现两者是完全一样的，即Cat.prototype.constructor等于Cat本身。</p>
<p>那么第三点怎么理解呢？既然constructor代表Cat构造函数本身，那么我们是不是可以用它来生成对象——类才具有的功能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CatConstructor = Cat.prototype.constructor;</span><br><span class="line"><span class="keyword">var</span> newObjCat = <span class="keyword">new</span> CatConstructor;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"objCat:"</span>, objCat, <span class="string">"newObjCat"</span>, newObjCat);</span><br></pre></td></tr></table></figure>
<p><img src="/img/prototype/cat-05.png" alt=""objCat:", objCat, "newObjCat", newObjCat"></p>
<p>如我们所料，上面输出的objCat和newObjCat结果是一样的，所以验证了第三点，类的原型的constructor属性即类本身</p>
<h2 id="this——到底指向了谁">this——到底指向了谁</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Cat.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Cat:"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"Cat-prototype:"</span>, <span class="keyword">this</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.init();				<span class="comment">/*this代表Cat类本身*/</span></span><br><span class="line">Cat.prototype.init();	<span class="comment">/*this代表Cat.prototype对象*/</span></span><br><span class="line"></span><br><span class="line">objCat.init();			<span class="comment">/*this代表objCat对象本身*/</span></span><br></pre></td></tr></table></figure>
<p><img src="/img/prototype/cat-06.png" alt="this——到底指向了谁"></p>
<p>从上图可以发现，输出为：</p>
<p>Cat.init():输出构成函数本身<br>Cat.prototype.init():输出类的原型对象<br>objCat.init(): 输出结果都是objCat对象本身且调用的是Cat.prototype.init方法</p>
<p>从上面我们可以知道this始终指向调用方法的对象本身</p>
<h3 id="构造函数中调用原型对象上绑定的方法——指向谁呢">构造函数中调用原型对象上绑定的方法——指向谁呢</h3><p>注：当我们在说构造函数的时候，其实是将构造函数和类等同起来</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*jquery构造函数模拟*/</span></span><br><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:大写的猫"</span>;</span><br><span class="line">	<span class="comment">/*调用原型上绑定的init方法*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Cat.prototype.init();</span><br><span class="line">&#125;;</span><br><span class="line">Cat.prototype = &#123;</span><br><span class="line">	init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;	<span class="comment">/*当做为构造函数时，返回值好像并没有啥用处*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.init.prototype = Cat.prototype;</span><br><span class="line"></span><br><span class="line">Cat();</span><br></pre></td></tr></table></figure>
<h3 id="稍稍复杂一点的情况">稍稍复杂一点的情况</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Cat = <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.animal = <span class="string">"Cat:大写的猫"</span>;</span><br><span class="line">	<span class="comment">/*调用原型上绑定的init方法*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Cat.prototype.init(params);</span><br><span class="line">&#125;;</span><br><span class="line">Cat.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal = params;</span><br><span class="line">        <span class="keyword">this</span>.type = params;</span><br><span class="line">        <span class="keyword">this</span>.color = params;</span><br><span class="line">    &#125;,</span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I like fish!"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.animal;</span><br><span class="line">    &#125;,</span><br><span class="line">    color: <span class="string">'yellow'</span></span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.init.prototype = Cat.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> redCat = Cat(<span class="string">"redCat"</span>);</span><br><span class="line"><span class="keyword">var</span> greenCat = Cat(<span class="string">"greenCat"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(redCat, greenCat);</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<p><img src="/img/prototype/cat-07.png" alt="jquery对象生成方式模拟"></p>
<p class="text-important">这里的init方法里的this指向的是Cat.prototype,init方法里的animal和Cat类的animal也没有关系,init这时相当于我们的构造函数，而它自身又是自身的prototype里的一个方法[是不是已已绕晕。。。]</p>

<ul>
<li>this.animal = params;</li>
<li>this.type = params;</li>
<li>this.color = params;</li>
</ul>
<p>它们是构造函数即类的属性，而init函数外面的color: ‘yellow’是挂在原型上的，所以生成的对象在访问color属性的时候是获取构造函数里的值[原型链继承的优先级]</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(redCat.__proto__.color);		<span class="comment">/*输出结果是:yelow,说明我的确是挂在类的原型上的*/</span></span><br></pre></td></tr></table></figure>
<p class="text-important">上述的jquery构造函数语法模拟的一个不足就是无法得到Cat类上的属性,如Cat里的animal.[如果你有好的方法获取请告知我]</p>
								</div>
								<a class="postMore" href="javascript:void(0);" data-show="false">......查看全文</a>
							
						</div>
						<hr>
						</div>
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				
				 	
				 	<div class="post-item">	
						<header>
							<h1>
								<a href="/2015/11/17/html语法标准/" target="_blank">html不能这么写，你知道吗？</a>
							</h1>
							<div class="post-info">
								<span class="post-time">
									<a class="permalink" href="" >2015-11-17</a>
								</span>
								<span class="post-tag">
									
									
										<a class="tag" href="http://www.yangxiaofu.com/tags/html/" target="_blank">html</a>
									
								</span>
							</div>
						</header>
						<div class="post-body">
							
								<div class="post-excerpt">
									<ul>
<li>a标签不可以嵌套交互式元素</li>
<li>块级元素可以包含内联元素和某些块级元素，内联元素不能包含块级元素，只能包含内联元素</li>
<li>p标签不能包含块级元素</li>
<li>这些标签不可包含块级元素</li>
<li>li标签可以包含div以及ul，ul的子元素应该只有li</li>
<li>元素并排（块级和块级并列，内联和内联并列)</li>
</ul>
								</div>
								<div class="post-more">
									<h2 id="标签错误嵌套">标签错误嵌套</h2><h3 id="语法错误">语法错误</h3><ul>
<li>a标签不可以嵌套交互式元素[a， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）]</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*下面这些写法浏览器是不能够正常解析的*/</span><br><span class="line">&lt;a href=""&gt;</span><br><span class="line">	&lt;a href=""&gt;click&lt;/a&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a href=""&gt;</span><br><span class="line">	&lt;button&gt;click&lt;/button&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a href=""&gt;</span><br><span class="line">	&lt;input type="text"&gt;</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;a href=""&gt;</span><br><span class="line">	&lt;textarea name="" id="" cols="10" rows="5"&gt;&lt;/textarea&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p><a href=""><a href="">click</a></a><a href=""><button>click</button></a><a href=""><input type="text"></a><a href=""><textarea name="" id="" cols="30" rows="10"></textarea></a></p>
<p>有的虽然解析正常，但却达不到预想的目的</p>
<h3 id="语义错误">语义错误</h3><p>页面可能正常解析，但不符合语义。这是因为浏览器自带容错机制，对于不规范的写法也能够正确的解析，各浏览器的容错机制不同，所以尽量按规范来写。</p>
<ul>
<li>块级元素可以包含内联元素和某些块级元素，内联元素不能包含块级元素，只能包含内联元素</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*规范的写法*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;h2&gt;jikexueyuan&lt;/h2&gt;</span><br><span class="line">	&lt;p&gt;IT education&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">/*不规范的写法*/</span><br><span class="line">&lt;span&gt;</span><br><span class="line">	&lt;div&gt;wrong&lt;/div&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>p标签不能包含块级元素</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*不规范的写法*/</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	&lt;h1&gt;&lt;/h1&gt;</span><br><span class="line">&lt;/p&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">	&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如下的标签不可包含块级元素</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">h1、h2、h3、h4、h5、h6、p</span><br><span class="line"></span><br><span class="line">/*不规范的写法*/</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">	&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">&lt;/h1&gt;</span><br><span class="line">&lt;h2&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>li标签可以包含div以及ul(这个是不是很牛，可以包含父级元素)</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*规范的写法*/</span><br><span class="line">&lt;li&gt;</span><br><span class="line">	&lt;ul&gt;</span><br><span class="line">		&lt;li&gt;&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;&lt;/li&gt;</span><br><span class="line">		&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;/ul&gt;</span><br><span class="line">	&lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">/*不规范的写法*/</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;a href=""&gt;迷路的a标签&lt;/a&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">	&lt;li&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>元素并排（块级和块级并列，内联和内联并列)</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">/*规范的写法*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;h2&gt;&lt;/h2&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;img src="" alt=""&gt;</span><br><span class="line">	&lt;a href=""&gt;&lt;/a&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*不规范的写法*/</span><br><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;我是内联元素&lt;/span&gt;</span><br><span class="line">	&lt;p&gt;我是块级元素&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>如有错误，请指出，欢迎补充其它一些错误情况。</p>
								</div>
								<a class="postMore" href="javascript:void(0);" data-show="false">......查看全文</a>
							
						</div>
						<hr>
						</div>
				 	
				
				 	
				
				 	
				
				 	
				
				</div>
			</article>
		</div>
	</div>

    <footer id="footer">
        <i id="upToTop"></i>
        <p>
            联系方式 <span>|</span> <a href="javascript:void(0);">yangxiaofuPL@163.com</a>
        </p>
    </footer>
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/highlight.min.js"></script>
    <script src="/js/post.js"></script>
    <script>
    $(document).ready(function() {
        $('.highlight').each(function(i, block) {
            hljs.highlightBlock(block);
        });
    });
    </script>
</body>

</html>
